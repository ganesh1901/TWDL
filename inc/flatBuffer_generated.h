// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FLATBUFFER_VIEWCONTROLLER_H_
#define FLATBUFFERS_GENERATED_FLATBUFFER_VIEWCONTROLLER_H_

#include "flatbuffers/flatbuffers.h"

namespace ViewController {

struct Mil_1553;
struct Mil_1553T;

struct IP_RRU;
struct IP_RRUT;

struct USB_RRU;
struct USB_RRUT;

struct Transaction;
struct TransactionT;

bool operator==(const Mil_1553T &lhs, const Mil_1553T &rhs);
bool operator!=(const Mil_1553T &lhs, const Mil_1553T &rhs);
bool operator==(const IP_RRUT &lhs, const IP_RRUT &rhs);
bool operator!=(const IP_RRUT &lhs, const IP_RRUT &rhs);
bool operator==(const USB_RRUT &lhs, const USB_RRUT &rhs);
bool operator!=(const USB_RRUT &lhs, const USB_RRUT &rhs);
bool operator==(const TransactionT &lhs, const TransactionT &rhs);
bool operator!=(const TransactionT &lhs, const TransactionT &rhs);

inline const flatbuffers::TypeTable *Mil_1553TypeTable();

inline const flatbuffers::TypeTable *IP_RRUTypeTable();

inline const flatbuffers::TypeTable *USB_RRUTypeTable();

inline const flatbuffers::TypeTable *TransactionTypeTable();

enum Interface_Type {
  Interface_Type_DIP = 0,
  Interface_Type_DOP = 1,
  Interface_Type_ADC = 2,
  Interface_Type_MIN = Interface_Type_DIP,
  Interface_Type_MAX = Interface_Type_ADC
};

inline const Interface_Type (&EnumValuesInterface_Type())[3] {
  static const Interface_Type values[] = {
    Interface_Type_DIP,
    Interface_Type_DOP,
    Interface_Type_ADC
  };
  return values;
}

inline const char * const *EnumNamesInterface_Type() {
  static const char * const names[4] = {
    "DIP",
    "DOP",
    "ADC",
    nullptr
  };
  return names;
}

inline const char *EnumNameInterface_Type(Interface_Type e) {
  if (e < Interface_Type_DIP || e > Interface_Type_ADC) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInterface_Type()[index];
}

enum IdentifyHardwareInterface {
  IdentifyHardwareInterface_NONE = 0,
  IdentifyHardwareInterface_Mil_1553 = 1,
  IdentifyHardwareInterface_IP_RRU = 2,
  IdentifyHardwareInterface_USB_RRU = 3,
  IdentifyHardwareInterface_MIN = IdentifyHardwareInterface_NONE,
  IdentifyHardwareInterface_MAX = IdentifyHardwareInterface_USB_RRU
};

inline const IdentifyHardwareInterface (&EnumValuesIdentifyHardwareInterface())[4] {
  static const IdentifyHardwareInterface values[] = {
    IdentifyHardwareInterface_NONE,
    IdentifyHardwareInterface_Mil_1553,
    IdentifyHardwareInterface_IP_RRU,
    IdentifyHardwareInterface_USB_RRU
  };
  return values;
}

inline const char * const *EnumNamesIdentifyHardwareInterface() {
  static const char * const names[5] = {
    "NONE",
    "Mil_1553",
    "IP_RRU",
    "USB_RRU",
    nullptr
  };
  return names;
}

inline const char *EnumNameIdentifyHardwareInterface(IdentifyHardwareInterface e) {
  if (e < IdentifyHardwareInterface_NONE || e > IdentifyHardwareInterface_USB_RRU) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIdentifyHardwareInterface()[index];
}

template<typename T> struct IdentifyHardwareInterfaceTraits {
  static const IdentifyHardwareInterface enum_value = IdentifyHardwareInterface_NONE;
};

template<> struct IdentifyHardwareInterfaceTraits<ViewController::Mil_1553> {
  static const IdentifyHardwareInterface enum_value = IdentifyHardwareInterface_Mil_1553;
};

template<> struct IdentifyHardwareInterfaceTraits<ViewController::IP_RRU> {
  static const IdentifyHardwareInterface enum_value = IdentifyHardwareInterface_IP_RRU;
};

template<> struct IdentifyHardwareInterfaceTraits<ViewController::USB_RRU> {
  static const IdentifyHardwareInterface enum_value = IdentifyHardwareInterface_USB_RRU;
};

struct IdentifyHardwareInterfaceUnion {
  IdentifyHardwareInterface type;
  void *value;

  IdentifyHardwareInterfaceUnion() : type(IdentifyHardwareInterface_NONE), value(nullptr) {}
  IdentifyHardwareInterfaceUnion(IdentifyHardwareInterfaceUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(IdentifyHardwareInterface_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  IdentifyHardwareInterfaceUnion(const IdentifyHardwareInterfaceUnion &) FLATBUFFERS_NOEXCEPT;
  IdentifyHardwareInterfaceUnion &operator=(const IdentifyHardwareInterfaceUnion &u) FLATBUFFERS_NOEXCEPT
    { IdentifyHardwareInterfaceUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  IdentifyHardwareInterfaceUnion &operator=(IdentifyHardwareInterfaceUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~IdentifyHardwareInterfaceUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = IdentifyHardwareInterfaceTraits<typename RT::TableType>::enum_value;
    if (type != IdentifyHardwareInterface_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, IdentifyHardwareInterface type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  ViewController::Mil_1553T *AsMil_1553() {
    return type == IdentifyHardwareInterface_Mil_1553 ?
      reinterpret_cast<ViewController::Mil_1553T *>(value) : nullptr;
  }
  const ViewController::Mil_1553T *AsMil_1553() const {
    return type == IdentifyHardwareInterface_Mil_1553 ?
      reinterpret_cast<const ViewController::Mil_1553T *>(value) : nullptr;
  }
  ViewController::IP_RRUT *AsIP_RRU() {
    return type == IdentifyHardwareInterface_IP_RRU ?
      reinterpret_cast<ViewController::IP_RRUT *>(value) : nullptr;
  }
  const ViewController::IP_RRUT *AsIP_RRU() const {
    return type == IdentifyHardwareInterface_IP_RRU ?
      reinterpret_cast<const ViewController::IP_RRUT *>(value) : nullptr;
  }
  ViewController::USB_RRUT *AsUSB_RRU() {
    return type == IdentifyHardwareInterface_USB_RRU ?
      reinterpret_cast<ViewController::USB_RRUT *>(value) : nullptr;
  }
  const ViewController::USB_RRUT *AsUSB_RRU() const {
    return type == IdentifyHardwareInterface_USB_RRU ?
      reinterpret_cast<const ViewController::USB_RRUT *>(value) : nullptr;
  }
};


inline bool operator==(const IdentifyHardwareInterfaceUnion &lhs, const IdentifyHardwareInterfaceUnion &rhs) {
  if (lhs.type != rhs.type) return false;
  switch (lhs.type) {
    case IdentifyHardwareInterface_NONE: {
      return true;
    }
    case IdentifyHardwareInterface_Mil_1553: {
      return *(reinterpret_cast<const ViewController::Mil_1553T *>(lhs.value)) ==
             *(reinterpret_cast<const ViewController::Mil_1553T *>(rhs.value));
    }
    case IdentifyHardwareInterface_IP_RRU: {
      return *(reinterpret_cast<const ViewController::IP_RRUT *>(lhs.value)) ==
             *(reinterpret_cast<const ViewController::IP_RRUT *>(rhs.value));
    }
    case IdentifyHardwareInterface_USB_RRU: {
      return *(reinterpret_cast<const ViewController::USB_RRUT *>(lhs.value)) ==
             *(reinterpret_cast<const ViewController::USB_RRUT *>(rhs.value));
    }
    default: {
      return false;
    }
  }
}

inline bool operator!=(const IdentifyHardwareInterfaceUnion &lhs, const IdentifyHardwareInterfaceUnion &rhs) {
    return !(lhs == rhs);
}

bool VerifyIdentifyHardwareInterface(flatbuffers::Verifier &verifier, const void *obj, IdentifyHardwareInterface type);
bool VerifyIdentifyHardwareInterfaceVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Mil_1553T : public flatbuffers::NativeTable {
  typedef Mil_1553 TableType;
  uint16_t rt;
  uint16_t subaddress;
  uint16_t direction;
  uint16_t wordcount;
  std::vector<uint8_t> payload;
  int16_t frequency;
  Mil_1553T()
      : rt(0),
        subaddress(0),
        direction(0),
        wordcount(0),
        frequency(0) {
  }
};

inline bool operator==(const Mil_1553T &lhs, const Mil_1553T &rhs) {
  return
      (lhs.rt == rhs.rt) &&
      (lhs.subaddress == rhs.subaddress) &&
      (lhs.direction == rhs.direction) &&
      (lhs.wordcount == rhs.wordcount) &&
      (lhs.payload == rhs.payload) &&
      (lhs.frequency == rhs.frequency);
}

inline bool operator!=(const Mil_1553T &lhs, const Mil_1553T &rhs) {
    return !(lhs == rhs);
}


struct Mil_1553 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Mil_1553T NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Mil_1553TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RT = 4,
    VT_SUBADDRESS = 6,
    VT_DIRECTION = 8,
    VT_WORDCOUNT = 10,
    VT_PAYLOAD = 12,
    VT_FREQUENCY = 14
  };
  uint16_t rt() const {
    return GetField<uint16_t>(VT_RT, 0);
  }
  bool mutate_rt(uint16_t _rt) {
    return SetField<uint16_t>(VT_RT, _rt, 0);
  }
  uint16_t subaddress() const {
    return GetField<uint16_t>(VT_SUBADDRESS, 0);
  }
  bool mutate_subaddress(uint16_t _subaddress) {
    return SetField<uint16_t>(VT_SUBADDRESS, _subaddress, 0);
  }
  uint16_t direction() const {
    return GetField<uint16_t>(VT_DIRECTION, 0);
  }
  bool mutate_direction(uint16_t _direction) {
    return SetField<uint16_t>(VT_DIRECTION, _direction, 0);
  }
  uint16_t wordcount() const {
    return GetField<uint16_t>(VT_WORDCOUNT, 0);
  }
  bool mutate_wordcount(uint16_t _wordcount) {
    return SetField<uint16_t>(VT_WORDCOUNT, _wordcount, 0);
  }
  const flatbuffers::Vector<uint8_t> *payload() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  flatbuffers::Vector<uint8_t> *mutable_payload() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  int16_t frequency() const {
    return GetField<int16_t>(VT_FREQUENCY, 0);
  }
  bool mutate_frequency(int16_t _frequency) {
    return SetField<int16_t>(VT_FREQUENCY, _frequency, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_RT) &&
           VerifyField<uint16_t>(verifier, VT_SUBADDRESS) &&
           VerifyField<uint16_t>(verifier, VT_DIRECTION) &&
           VerifyField<uint16_t>(verifier, VT_WORDCOUNT) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.VerifyVector(payload()) &&
           VerifyField<int16_t>(verifier, VT_FREQUENCY) &&
           verifier.EndTable();
  }
  Mil_1553T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Mil_1553T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Mil_1553> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Mil_1553T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Mil_1553Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rt(uint16_t rt) {
    fbb_.AddElement<uint16_t>(Mil_1553::VT_RT, rt, 0);
  }
  void add_subaddress(uint16_t subaddress) {
    fbb_.AddElement<uint16_t>(Mil_1553::VT_SUBADDRESS, subaddress, 0);
  }
  void add_direction(uint16_t direction) {
    fbb_.AddElement<uint16_t>(Mil_1553::VT_DIRECTION, direction, 0);
  }
  void add_wordcount(uint16_t wordcount) {
    fbb_.AddElement<uint16_t>(Mil_1553::VT_WORDCOUNT, wordcount, 0);
  }
  void add_payload(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload) {
    fbb_.AddOffset(Mil_1553::VT_PAYLOAD, payload);
  }
  void add_frequency(int16_t frequency) {
    fbb_.AddElement<int16_t>(Mil_1553::VT_FREQUENCY, frequency, 0);
  }
  explicit Mil_1553Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Mil_1553Builder &operator=(const Mil_1553Builder &);
  flatbuffers::Offset<Mil_1553> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mil_1553>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mil_1553> CreateMil_1553(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t rt = 0,
    uint16_t subaddress = 0,
    uint16_t direction = 0,
    uint16_t wordcount = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload = 0,
    int16_t frequency = 0) {
  Mil_1553Builder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_frequency(frequency);
  builder_.add_wordcount(wordcount);
  builder_.add_direction(direction);
  builder_.add_subaddress(subaddress);
  builder_.add_rt(rt);
  return builder_.Finish();
}

inline flatbuffers::Offset<Mil_1553> CreateMil_1553Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t rt = 0,
    uint16_t subaddress = 0,
    uint16_t direction = 0,
    uint16_t wordcount = 0,
    const std::vector<uint8_t> *payload = nullptr,
    int16_t frequency = 0) {
  auto payload__ = payload ? _fbb.CreateVector<uint8_t>(*payload) : 0;
  return ViewController::CreateMil_1553(
      _fbb,
      rt,
      subaddress,
      direction,
      wordcount,
      payload__,
      frequency);
}

flatbuffers::Offset<Mil_1553> CreateMil_1553(flatbuffers::FlatBufferBuilder &_fbb, const Mil_1553T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IP_RRUT : public flatbuffers::NativeTable {
  typedef IP_RRU TableType;
  ViewController::Interface_Type i_type;
  uint16_t slot;
  uint16_t port;
  uint16_t channel;
  int16_t value;
  float value2;
  IP_RRUT()
      : i_type(ViewController::Interface_Type_DOP),
        slot(0),
        port(0),
        channel(0),
        value(0),
        value2(0.0f) {
  }
};

inline bool operator==(const IP_RRUT &lhs, const IP_RRUT &rhs) {
  return
      (lhs.i_type == rhs.i_type) &&
      (lhs.slot == rhs.slot) &&
      (lhs.port == rhs.port) &&
      (lhs.channel == rhs.channel) &&
      (lhs.value == rhs.value) &&
      (lhs.value2 == rhs.value2);
}

inline bool operator!=(const IP_RRUT &lhs, const IP_RRUT &rhs) {
    return !(lhs == rhs);
}


struct IP_RRU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IP_RRUT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IP_RRUTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_I_TYPE = 4,
    VT_SLOT = 6,
    VT_PORT = 8,
    VT_CHANNEL = 10,
    VT_VALUE = 12,
    VT_VALUE2 = 14
  };
  ViewController::Interface_Type i_type() const {
    return static_cast<ViewController::Interface_Type>(GetField<int8_t>(VT_I_TYPE, 1));
  }
  bool mutate_i_type(ViewController::Interface_Type _i_type) {
    return SetField<int8_t>(VT_I_TYPE, static_cast<int8_t>(_i_type), 1);
  }
  uint16_t slot() const {
    return GetField<uint16_t>(VT_SLOT, 0);
  }
  bool mutate_slot(uint16_t _slot) {
    return SetField<uint16_t>(VT_SLOT, _slot, 0);
  }
  uint16_t port() const {
    return GetField<uint16_t>(VT_PORT, 0);
  }
  bool mutate_port(uint16_t _port) {
    return SetField<uint16_t>(VT_PORT, _port, 0);
  }
  uint16_t channel() const {
    return GetField<uint16_t>(VT_CHANNEL, 0);
  }
  bool mutate_channel(uint16_t _channel) {
    return SetField<uint16_t>(VT_CHANNEL, _channel, 0);
  }
  int16_t value() const {
    return GetField<int16_t>(VT_VALUE, 0);
  }
  bool mutate_value(int16_t _value) {
    return SetField<int16_t>(VT_VALUE, _value, 0);
  }
  float value2() const {
    return GetField<float>(VT_VALUE2, 0.0f);
  }
  bool mutate_value2(float _value2) {
    return SetField<float>(VT_VALUE2, _value2, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_I_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_SLOT) &&
           VerifyField<uint16_t>(verifier, VT_PORT) &&
           VerifyField<uint16_t>(verifier, VT_CHANNEL) &&
           VerifyField<int16_t>(verifier, VT_VALUE) &&
           VerifyField<float>(verifier, VT_VALUE2) &&
           verifier.EndTable();
  }
  IP_RRUT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IP_RRUT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IP_RRU> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IP_RRUT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IP_RRUBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_i_type(ViewController::Interface_Type i_type) {
    fbb_.AddElement<int8_t>(IP_RRU::VT_I_TYPE, static_cast<int8_t>(i_type), 1);
  }
  void add_slot(uint16_t slot) {
    fbb_.AddElement<uint16_t>(IP_RRU::VT_SLOT, slot, 0);
  }
  void add_port(uint16_t port) {
    fbb_.AddElement<uint16_t>(IP_RRU::VT_PORT, port, 0);
  }
  void add_channel(uint16_t channel) {
    fbb_.AddElement<uint16_t>(IP_RRU::VT_CHANNEL, channel, 0);
  }
  void add_value(int16_t value) {
    fbb_.AddElement<int16_t>(IP_RRU::VT_VALUE, value, 0);
  }
  void add_value2(float value2) {
    fbb_.AddElement<float>(IP_RRU::VT_VALUE2, value2, 0.0f);
  }
  explicit IP_RRUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IP_RRUBuilder &operator=(const IP_RRUBuilder &);
  flatbuffers::Offset<IP_RRU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IP_RRU>(end);
    return o;
  }
};

inline flatbuffers::Offset<IP_RRU> CreateIP_RRU(
    flatbuffers::FlatBufferBuilder &_fbb,
    ViewController::Interface_Type i_type = ViewController::Interface_Type_DOP,
    uint16_t slot = 0,
    uint16_t port = 0,
    uint16_t channel = 0,
    int16_t value = 0,
    float value2 = 0.0f) {
  IP_RRUBuilder builder_(_fbb);
  builder_.add_value2(value2);
  builder_.add_value(value);
  builder_.add_channel(channel);
  builder_.add_port(port);
  builder_.add_slot(slot);
  builder_.add_i_type(i_type);
  return builder_.Finish();
}

flatbuffers::Offset<IP_RRU> CreateIP_RRU(flatbuffers::FlatBufferBuilder &_fbb, const IP_RRUT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct USB_RRUT : public flatbuffers::NativeTable {
  typedef USB_RRU TableType;
  ViewController::Interface_Type i_type;
  int16_t channel;
  int16_t value;
  USB_RRUT()
      : i_type(ViewController::Interface_Type_DOP),
        channel(0),
        value(0) {
  }
};

inline bool operator==(const USB_RRUT &lhs, const USB_RRUT &rhs) {
  return
      (lhs.i_type == rhs.i_type) &&
      (lhs.channel == rhs.channel) &&
      (lhs.value == rhs.value);
}

inline bool operator!=(const USB_RRUT &lhs, const USB_RRUT &rhs) {
    return !(lhs == rhs);
}


struct USB_RRU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef USB_RRUT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return USB_RRUTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_I_TYPE = 4,
    VT_CHANNEL = 6,
    VT_VALUE = 8
  };
  ViewController::Interface_Type i_type() const {
    return static_cast<ViewController::Interface_Type>(GetField<int8_t>(VT_I_TYPE, 1));
  }
  bool mutate_i_type(ViewController::Interface_Type _i_type) {
    return SetField<int8_t>(VT_I_TYPE, static_cast<int8_t>(_i_type), 1);
  }
  int16_t channel() const {
    return GetField<int16_t>(VT_CHANNEL, 0);
  }
  bool mutate_channel(int16_t _channel) {
    return SetField<int16_t>(VT_CHANNEL, _channel, 0);
  }
  int16_t value() const {
    return GetField<int16_t>(VT_VALUE, 0);
  }
  bool mutate_value(int16_t _value) {
    return SetField<int16_t>(VT_VALUE, _value, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_I_TYPE) &&
           VerifyField<int16_t>(verifier, VT_CHANNEL) &&
           VerifyField<int16_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
  USB_RRUT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(USB_RRUT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<USB_RRU> Pack(flatbuffers::FlatBufferBuilder &_fbb, const USB_RRUT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct USB_RRUBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_i_type(ViewController::Interface_Type i_type) {
    fbb_.AddElement<int8_t>(USB_RRU::VT_I_TYPE, static_cast<int8_t>(i_type), 1);
  }
  void add_channel(int16_t channel) {
    fbb_.AddElement<int16_t>(USB_RRU::VT_CHANNEL, channel, 0);
  }
  void add_value(int16_t value) {
    fbb_.AddElement<int16_t>(USB_RRU::VT_VALUE, value, 0);
  }
  explicit USB_RRUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  USB_RRUBuilder &operator=(const USB_RRUBuilder &);
  flatbuffers::Offset<USB_RRU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<USB_RRU>(end);
    return o;
  }
};

inline flatbuffers::Offset<USB_RRU> CreateUSB_RRU(
    flatbuffers::FlatBufferBuilder &_fbb,
    ViewController::Interface_Type i_type = ViewController::Interface_Type_DOP,
    int16_t channel = 0,
    int16_t value = 0) {
  USB_RRUBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_channel(channel);
  builder_.add_i_type(i_type);
  return builder_.Finish();
}

flatbuffers::Offset<USB_RRU> CreateUSB_RRU(flatbuffers::FlatBufferBuilder &_fbb, const USB_RRUT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransactionT : public flatbuffers::NativeTable {
  typedef Transaction TableType;
  IdentifyHardwareInterfaceUnion queryOnInterface;
  TransactionT() {
  }
};

inline bool operator==(const TransactionT &lhs, const TransactionT &rhs) {
  return
      (lhs.queryOnInterface == rhs.queryOnInterface);
}

inline bool operator!=(const TransactionT &lhs, const TransactionT &rhs) {
    return !(lhs == rhs);
}


struct Transaction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransactionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TransactionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_QUERYONINTERFACE_TYPE = 4,
    VT_QUERYONINTERFACE = 6
  };
  ViewController::IdentifyHardwareInterface queryOnInterface_type() const {
    return static_cast<ViewController::IdentifyHardwareInterface>(GetField<uint8_t>(VT_QUERYONINTERFACE_TYPE, 0));
  }
  bool mutate_queryOnInterface_type(ViewController::IdentifyHardwareInterface _queryOnInterface_type) {
    return SetField<uint8_t>(VT_QUERYONINTERFACE_TYPE, static_cast<uint8_t>(_queryOnInterface_type), 0);
  }
  const void *queryOnInterface() const {
    return GetPointer<const void *>(VT_QUERYONINTERFACE);
  }
  template<typename T> const T *queryOnInterface_as() const;
  const ViewController::Mil_1553 *queryOnInterface_as_Mil_1553() const {
    return queryOnInterface_type() == ViewController::IdentifyHardwareInterface_Mil_1553 ? static_cast<const ViewController::Mil_1553 *>(queryOnInterface()) : nullptr;
  }
  const ViewController::IP_RRU *queryOnInterface_as_IP_RRU() const {
    return queryOnInterface_type() == ViewController::IdentifyHardwareInterface_IP_RRU ? static_cast<const ViewController::IP_RRU *>(queryOnInterface()) : nullptr;
  }
  const ViewController::USB_RRU *queryOnInterface_as_USB_RRU() const {
    return queryOnInterface_type() == ViewController::IdentifyHardwareInterface_USB_RRU ? static_cast<const ViewController::USB_RRU *>(queryOnInterface()) : nullptr;
  }
  void *mutable_queryOnInterface() {
    return GetPointer<void *>(VT_QUERYONINTERFACE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_QUERYONINTERFACE_TYPE) &&
           VerifyOffset(verifier, VT_QUERYONINTERFACE) &&
           VerifyIdentifyHardwareInterface(verifier, queryOnInterface(), queryOnInterface_type()) &&
           verifier.EndTable();
  }
  TransactionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransactionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Transaction> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransactionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const ViewController::Mil_1553 *Transaction::queryOnInterface_as<ViewController::Mil_1553>() const {
  return queryOnInterface_as_Mil_1553();
}

template<> inline const ViewController::IP_RRU *Transaction::queryOnInterface_as<ViewController::IP_RRU>() const {
  return queryOnInterface_as_IP_RRU();
}

template<> inline const ViewController::USB_RRU *Transaction::queryOnInterface_as<ViewController::USB_RRU>() const {
  return queryOnInterface_as_USB_RRU();
}

struct TransactionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_queryOnInterface_type(ViewController::IdentifyHardwareInterface queryOnInterface_type) {
    fbb_.AddElement<uint8_t>(Transaction::VT_QUERYONINTERFACE_TYPE, static_cast<uint8_t>(queryOnInterface_type), 0);
  }
  void add_queryOnInterface(flatbuffers::Offset<void> queryOnInterface) {
    fbb_.AddOffset(Transaction::VT_QUERYONINTERFACE, queryOnInterface);
  }
  explicit TransactionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransactionBuilder &operator=(const TransactionBuilder &);
  flatbuffers::Offset<Transaction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Transaction>(end);
    return o;
  }
};

inline flatbuffers::Offset<Transaction> CreateTransaction(
    flatbuffers::FlatBufferBuilder &_fbb,
    ViewController::IdentifyHardwareInterface queryOnInterface_type = ViewController::IdentifyHardwareInterface_NONE,
    flatbuffers::Offset<void> queryOnInterface = 0) {
  TransactionBuilder builder_(_fbb);
  builder_.add_queryOnInterface(queryOnInterface);
  builder_.add_queryOnInterface_type(queryOnInterface_type);
  return builder_.Finish();
}

flatbuffers::Offset<Transaction> CreateTransaction(flatbuffers::FlatBufferBuilder &_fbb, const TransactionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline Mil_1553T *Mil_1553::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Mil_1553T();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Mil_1553::UnPackTo(Mil_1553T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rt(); _o->rt = _e; };
  { auto _e = subaddress(); _o->subaddress = _e; };
  { auto _e = direction(); _o->direction = _e; };
  { auto _e = wordcount(); _o->wordcount = _e; };
  { auto _e = payload(); if (_e) { _o->payload.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->payload[_i] = _e->Get(_i); } } };
  { auto _e = frequency(); _o->frequency = _e; };
}

inline flatbuffers::Offset<Mil_1553> Mil_1553::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Mil_1553T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMil_1553(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Mil_1553> CreateMil_1553(flatbuffers::FlatBufferBuilder &_fbb, const Mil_1553T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Mil_1553T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rt = _o->rt;
  auto _subaddress = _o->subaddress;
  auto _direction = _o->direction;
  auto _wordcount = _o->wordcount;
  auto _payload = _o->payload.size() ? _fbb.CreateVector(_o->payload) : 0;
  auto _frequency = _o->frequency;
  return ViewController::CreateMil_1553(
      _fbb,
      _rt,
      _subaddress,
      _direction,
      _wordcount,
      _payload,
      _frequency);
}

inline IP_RRUT *IP_RRU::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new IP_RRUT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void IP_RRU::UnPackTo(IP_RRUT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = i_type(); _o->i_type = _e; };
  { auto _e = slot(); _o->slot = _e; };
  { auto _e = port(); _o->port = _e; };
  { auto _e = channel(); _o->channel = _e; };
  { auto _e = value(); _o->value = _e; };
  { auto _e = value2(); _o->value2 = _e; };
}

inline flatbuffers::Offset<IP_RRU> IP_RRU::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IP_RRUT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIP_RRU(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IP_RRU> CreateIP_RRU(flatbuffers::FlatBufferBuilder &_fbb, const IP_RRUT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IP_RRUT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _i_type = _o->i_type;
  auto _slot = _o->slot;
  auto _port = _o->port;
  auto _channel = _o->channel;
  auto _value = _o->value;
  auto _value2 = _o->value2;
  return ViewController::CreateIP_RRU(
      _fbb,
      _i_type,
      _slot,
      _port,
      _channel,
      _value,
      _value2);
}

inline USB_RRUT *USB_RRU::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new USB_RRUT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void USB_RRU::UnPackTo(USB_RRUT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = i_type(); _o->i_type = _e; };
  { auto _e = channel(); _o->channel = _e; };
  { auto _e = value(); _o->value = _e; };
}

inline flatbuffers::Offset<USB_RRU> USB_RRU::Pack(flatbuffers::FlatBufferBuilder &_fbb, const USB_RRUT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUSB_RRU(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<USB_RRU> CreateUSB_RRU(flatbuffers::FlatBufferBuilder &_fbb, const USB_RRUT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const USB_RRUT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _i_type = _o->i_type;
  auto _channel = _o->channel;
  auto _value = _o->value;
  return ViewController::CreateUSB_RRU(
      _fbb,
      _i_type,
      _channel,
      _value);
}

inline TransactionT *Transaction::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TransactionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Transaction::UnPackTo(TransactionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = queryOnInterface_type(); _o->queryOnInterface.type = _e; };
  { auto _e = queryOnInterface(); if (_e) _o->queryOnInterface.value = IdentifyHardwareInterfaceUnion::UnPack(_e, queryOnInterface_type(), _resolver); };
}

inline flatbuffers::Offset<Transaction> Transaction::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransactionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransaction(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Transaction> CreateTransaction(flatbuffers::FlatBufferBuilder &_fbb, const TransactionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransactionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _queryOnInterface_type = _o->queryOnInterface.type;
  auto _queryOnInterface = _o->queryOnInterface.Pack(_fbb);
  return ViewController::CreateTransaction(
      _fbb,
      _queryOnInterface_type,
      _queryOnInterface);
}

inline bool VerifyIdentifyHardwareInterface(flatbuffers::Verifier &verifier, const void *obj, IdentifyHardwareInterface type) {
  switch (type) {
    case IdentifyHardwareInterface_NONE: {
      return true;
    }
    case IdentifyHardwareInterface_Mil_1553: {
      auto ptr = reinterpret_cast<const ViewController::Mil_1553 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case IdentifyHardwareInterface_IP_RRU: {
      auto ptr = reinterpret_cast<const ViewController::IP_RRU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case IdentifyHardwareInterface_USB_RRU: {
      auto ptr = reinterpret_cast<const ViewController::USB_RRU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyIdentifyHardwareInterfaceVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyIdentifyHardwareInterface(
        verifier,  values->Get(i), types->GetEnum<IdentifyHardwareInterface>(i))) {
      return false;
    }
  }
  return true;
}

inline void *IdentifyHardwareInterfaceUnion::UnPack(const void *obj, IdentifyHardwareInterface type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case IdentifyHardwareInterface_Mil_1553: {
      auto ptr = reinterpret_cast<const ViewController::Mil_1553 *>(obj);
      return ptr->UnPack(resolver);
    }
    case IdentifyHardwareInterface_IP_RRU: {
      auto ptr = reinterpret_cast<const ViewController::IP_RRU *>(obj);
      return ptr->UnPack(resolver);
    }
    case IdentifyHardwareInterface_USB_RRU: {
      auto ptr = reinterpret_cast<const ViewController::USB_RRU *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> IdentifyHardwareInterfaceUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case IdentifyHardwareInterface_Mil_1553: {
      auto ptr = reinterpret_cast<const ViewController::Mil_1553T *>(value);
      return CreateMil_1553(_fbb, ptr, _rehasher).Union();
    }
    case IdentifyHardwareInterface_IP_RRU: {
      auto ptr = reinterpret_cast<const ViewController::IP_RRUT *>(value);
      return CreateIP_RRU(_fbb, ptr, _rehasher).Union();
    }
    case IdentifyHardwareInterface_USB_RRU: {
      auto ptr = reinterpret_cast<const ViewController::USB_RRUT *>(value);
      return CreateUSB_RRU(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline IdentifyHardwareInterfaceUnion::IdentifyHardwareInterfaceUnion(const IdentifyHardwareInterfaceUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case IdentifyHardwareInterface_Mil_1553: {
      value = new ViewController::Mil_1553T(*reinterpret_cast<ViewController::Mil_1553T *>(u.value));
      break;
    }
    case IdentifyHardwareInterface_IP_RRU: {
      value = new ViewController::IP_RRUT(*reinterpret_cast<ViewController::IP_RRUT *>(u.value));
      break;
    }
    case IdentifyHardwareInterface_USB_RRU: {
      value = new ViewController::USB_RRUT(*reinterpret_cast<ViewController::USB_RRUT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void IdentifyHardwareInterfaceUnion::Reset() {
  switch (type) {
    case IdentifyHardwareInterface_Mil_1553: {
      auto ptr = reinterpret_cast<ViewController::Mil_1553T *>(value);
      delete ptr;
      break;
    }
    case IdentifyHardwareInterface_IP_RRU: {
      auto ptr = reinterpret_cast<ViewController::IP_RRUT *>(value);
      delete ptr;
      break;
    }
    case IdentifyHardwareInterface_USB_RRU: {
      auto ptr = reinterpret_cast<ViewController::USB_RRUT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = IdentifyHardwareInterface_NONE;
}

inline const flatbuffers::TypeTable *Interface_TypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ViewController::Interface_TypeTypeTable
  };
  static const char * const names[] = {
    "DIP",
    "DOP",
    "ADC"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IdentifyHardwareInterfaceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ViewController::Mil_1553TypeTable,
    ViewController::IP_RRUTypeTable,
    ViewController::USB_RRUTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "Mil_1553",
    "IP_RRU",
    "USB_RRU"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Mil_1553TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_SHORT, 0, -1 }
  };
  static const char * const names[] = {
    "rt",
    "subaddress",
    "direction",
    "wordcount",
    "payload",
    "frequency"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IP_RRUTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_SHORT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ViewController::Interface_TypeTypeTable
  };
  static const char * const names[] = {
    "i_type",
    "slot",
    "port",
    "channel",
    "value",
    "value2"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *USB_RRUTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_SHORT, 0, -1 },
    { flatbuffers::ET_SHORT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ViewController::Interface_TypeTypeTable
  };
  static const char * const names[] = {
    "i_type",
    "channel",
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TransactionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ViewController::IdentifyHardwareInterfaceTypeTable
  };
  static const char * const names[] = {
    "queryOnInterface_type",
    "queryOnInterface"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const ViewController::Transaction *GetTransaction(const void *buf) {
  return flatbuffers::GetRoot<ViewController::Transaction>(buf);
}

inline const ViewController::Transaction *GetSizePrefixedTransaction(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ViewController::Transaction>(buf);
}

inline Transaction *GetMutableTransaction(void *buf) {
  return flatbuffers::GetMutableRoot<Transaction>(buf);
}

inline bool VerifyTransactionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ViewController::Transaction>(nullptr);
}

inline bool VerifySizePrefixedTransactionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ViewController::Transaction>(nullptr);
}

inline void FinishTransactionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ViewController::Transaction> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTransactionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ViewController::Transaction> root) {
  fbb.FinishSizePrefixed(root);
}

inline flatbuffers::unique_ptr<ViewController::TransactionT> UnPackTransaction(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return flatbuffers::unique_ptr<ViewController::TransactionT>(GetTransaction(buf)->UnPack(res));
}

inline flatbuffers::unique_ptr<ViewController::TransactionT> UnPackSizePrefixedTransaction(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return flatbuffers::unique_ptr<ViewController::TransactionT>(GetSizePrefixedTransaction(buf)->UnPack(res));
}

}  // namespace ViewController

#endif  // FLATBUFFERS_GENERATED_FLATBUFFER_VIEWCONTROLLER_H_
